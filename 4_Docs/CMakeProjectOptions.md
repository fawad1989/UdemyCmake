#CMake Tutorial
## Generating a Proejct
```bash
cmake [<options>] -S <path-to-source> -B <path-to-build>
```

Assuming the CMakeLists.txt is in the root directory. Files can be generated by following the folling commands
```cmake
mkdir build && cd build
cmake -S .. -B . -V . -G . #-> Option 1 to build targets with spefic flags
    # Different Flags are as below ToDo: Need to populate the different flags and their meaning
    #-S = Source Relative path or address,
    #-B = Build the file usualy build folder or can be different as per need,
    #-V = ,
    #-G = Generator is a build system under the hood. can be Unix make file or Visual Studio 16 version compiler tool chain,
    #-D =  for Options i.e. Features for Variable to turn ON or OFF (e.g. If you dont want to Turn the compilation OFF and dont include the main.cpp) Other options are build type.
cmake .. # -> Option2 to build all targets
```

To upgrade the CMake Project
```bash
cd build
cmake .
```

## Generator for GCC and Clang

```bash
cd build
cmake -S .. -B . -G "UNIX Makefiles" # -> Option 1
cmake .. -G "UNIX Makefiles" # -> Option 2
```

## Generator for MSVC

```bash
cd build
cmake -S .. -B . -G "Visual Studio 16 2019" # -> Option 1
cmake .. G "Visual Studio 16 2019" # -> Option 2
```

## Specifying Build Type
Per default, build type mostly is Debug so no need to mention
If the project need to be in release type, there is a need to mention Release
```bash
cmake -DCMAKE_BUILD_TYPE=Release
```

## Passing Options

If you have set some options in the CMakeLists, You can pass value in command line. Used in case of Sanitizer and customs functionality

```bash
cd build
cmake -DMY_OPTIONS - [ON|OFF] .. # -D is the keyword for turning on or off the options or variables
```

## Specify the Build Target (Option 1)

```bash
cd build
make ExternalLibraries_Executable
```

## Running the Executable

In case there is a need to run the executable. For example executable file name is Executable

```bash
cd build
./<Executable file address>/Executable
```

## Different Linking Types

```bash
cmake
add_libraryA(...)
add_libraryB(...)
add_libraryC(...)
```

### PUBLIC
When A links in B as *PUBLIC*, it says that A uses B in its implementation, and B is also used in A's public API. Hence, C can use B since it is part of the public API of A.
```bash
cmake
target_link_libraries(A PUBLIC B)
target_link_libraries(C PUBLIC A)
```

### PRIVATE
When A links in B as *PRIVATE*, it is saying that A uses B in its implementation, but B is not used in any part of A's public API. Any code that makes calls into A would not need to refer directly to anything from B.
```bash 
cmake
target_link_libraries(A PRIVATE B)
target_link_libraries(C PRIVATE A)
```

### INTERFACE
In general, used for header-only libraries.

```bash
cmake
add_library(D INTERFACE)
target_include_directories(D INTERFACE {CMAKE_CURRENT_SOURCE_DIR}/include)
```

## Different Library Types

### Library

A binary file that contains information about code.
A library cannot be executed on its own.
An application utilizes a library.

### Shared

- Linux: *.so
- MacOS: *.dylib
- Windows: *.dll

Shared libraries reduce the amount of code that is duplicated in each program that makes use of the library, keeping the binaries small.
Shared libraries will however have a small additional cost for the execution.
In general the shared library is in the same directory as the executable.

### Static

- Linux/MacOS: *.a
- Windows: *.lib

Static libraries increase the overall size of the binary, but it means that you don't need to carry along a copy of the library that is being used.
As the code is connected at compile time there are not any additional run-time loading costs.
